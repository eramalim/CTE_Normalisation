-- 1. Identify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF.

-- actor_award violates the rule of 1NF -- according to 1NF rule 'every coloumn have a atomic value' but in actor_award table 
-- there are multiple -- values in award column . -- for normalize in 1NF we have to creat a new table for award

-- 2. Choose a table in Sakila and describe how you would determine whether it is in 2NF If it violates 2NF, 
-- explain the steps to normalize it

--  film table from sakila databse violates 2nf because of the special features column special feature column on the
-- table violate 1nf and 2nf has a rule that table is in 1nf 
-- Identify Partial Dependencies: all the non-prime attributes like title , discription , release_year etc are fully dependent on the 
-- primary key which is film id we can create a another table and make them columns foreign keys and 
-- these foreign keys make reference to that film id table by using these steps we can avoid 2 nf .

-- 3. Identify a table in Sakila that violates 3NF Describe the transitive dependencies present and outline the 
-- steps to normalize the table to 3NF

-- if we saw the customer table in the sakila database we get to know that the column name address_id is linked with store id 
-- and both are non key attribute and 3nf stays that table is in 2 nf from and it ensure that all the non key attribute column on the
-- table are not related with each other (one non key attribute column related to other non key attribute column) so because of that it 
-- violate 2 and 3 nf

-- steps to prevent 3nf
-- 1, analyse the violation 
-- 2, create new table to store data 
-- 3 , update customer table (make store id as foreign key ) 
-- 4 , update address info. (so it reference to the foreign key )

-- 4. Take a specific table in Sakila and guide through the process of normalizing it from the initial 
-- unnormalized form up to at least 2NF 

-- In this database "film " table seems like unnormalize form so we discuss the normalizetion process up to 2nf 
-- This table 
-- may not be in 1st Normal Form (1NF) because it has repeating groups (like special_features) 
-- and multiple values in a single column. To normalize it, we can follow these steps:
-- Step 1: Identify the Primary Key 
-- The film_id column seems suitable as the primary key for the film table.
-- Step 2: Eliminate Repeating Groups 
-- The special_features column contains multiple values, violating 1NF. We can create a new table for special features:
-- Step 3: Eliminate Partial Dependencies 
-- Now, let's check for partial dependencies. If there are any, we need to create separate tables for those.
-- In this case, it seems like language_id and original_language_id are partially dependent on film_id.
-- We can create a new table for languages:
-- Step 4: Ensure No Transitive Dependencies 
-- Now, let's check for transitive dependencies. If any are found, create separate tables for those.
-- In this example, there are no apparent transitive dependencies. The table is now in 2nd Normal Form (2NF).

-- 5. Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the film_actor
-- tables
with film_counts as 
( select a.first_name , a.last_name , count(fc.film_id) as film_count from actor a inner join film_actor fc
on a.actor_id = fc.actor_id group by a.first_name, a.last_name )
select distinct * from film_counts ;

-- 6. Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the
-- category  table in Sakilaa

select * from category;
-- there is no subcategory in the category table

-- 7. Create a CTE that combines information from the film and language tables to display the film title, language name, and rental rate.
With film_language as 
( select f.title, l.name, f.rental_rate from film f inner join language l on f.language_id = l.language_id)
select * from film_language; 


-- 8. Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and payments tables.
With revenue_generated as
( select c.customer_id, c.first_name , c.last_name, sum(p.amount) as total_amount
from customer c inner join payment p on c.customer_id = p.customer_id group by p.customer_id order by total_amount desc)
select * from revenue_generated;


-- 9. Utilize a CTE with a window function to rank films based on their rental duration from the film table.
With ranks as 
(select film_id, title, rental_duration, rank() over(order by rental_duration) as ranked from film)
select * from ranks;

--  10. Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer
-- table to retrieve additional customer details
with customer_details as 
(select customer_id, count(customer_id) as customer_count from rental group by customer_id having count(customer_id) > 2),
additional_details as
(select cd.customer_id, c.first_name , c.last_name, cd.customer_count from customer c inner join customer_details cd 
on c.customer_id = cd.customer_id)
select * from additional_details ;

-- 11. Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from the rental table.
With total_rentals as
( select monthname(rental_date), count(rental_id) as counts from rental group by monthname(rental_date) order by counts desc)
select * from total_rentals;

-- Use a CTE to pivot the data from the table to display the total payments made by each customer in
-- separate columns for differnt payment methods.
-- In this mavenmovies database there is no any column name as payments mothod so we use amount in the place of payments method

with customer_payments as( select c.customer_id , sum(p.amount) as payment_amount 
from payment p join customer c on c.customer_id = p. customer_id group by customer_id )
select customer_id , payment_amount from customer_payments ORDER BY customer_id;

-- 13. Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.
select a.actor_id as actor_id1, b.actor_id as actor_id2 , a.film_id from film_actor a , film_actor b
where a.film_id =  b.film_id;

-- 14. Implement a recursive CTE to find all employees in the staff table who report to a specific manager,considering the reports_to column.

select * from staff;
-- There is no reports_to column in the staff table.
